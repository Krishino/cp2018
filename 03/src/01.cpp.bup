#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <random>
#include <fstream>

int main(int argc, char *argv[])
{
    int Schritte = pow(10, 4);

    // Erstelle mehrere H
    std::vector<double> h = {-5., -4., -3., -2., -1., 0., 1., 2., 3., 4.};
    double H;
    int anzahl_H = pow(10, 2);

    // wahrscheinlichkeiten fuer die beiden zustaende
    double p1, p2;

    // start und endvektor
    std::vector<double> s0;
    std::vector<double> s1 = {0., 0.};
    std::vector<std::vector<double>> M;

    // Random Numbers
    std::mt19937 rng;
    rng.seed(std::random_device()());
    std::uniform_real_distribution<double> dist_H(-5., 5.);

    std::uniform_real_distribution<double> dist_uni(0., 1.);

    std::cout << "Magnetfeld: Wahrscheinlichkeiten Spin = [1 -1]" << std::endl;
    std::ofstream myfile ("./build/01_b.txt");
    myfile << "# H p(s=1) p(s=-1)" << std::endl;
    for (int i = 0; i < anzahl_H; i++) {
        // H = h[i];  // weise H zu
        H = dist_H(rng);
        s0 = {1., 0.};
        // s0 = {0., 1.};

        // passe wahrscheinlichkeiten an, jenachdem was H ist
        p1 = pow(M_E, H) / (pow(M_E, H) + pow(M_E, -H));
        p2 = pow(M_E, -H) / (pow(M_E, H) + pow(M_E, -H));

        // erstelle metropolis matrix
        M = {{p1, p2},
             {p1, p2}};

        // def _ising_update(field, n, m, beta):
//         total = 0
//         N, M = field.shape
//         for i in range(n-1, n+2):
//             for j in range(m-1, m+2):
//                 if i == n and j == m:
//                     continue
//                 total += field[i % N, j % M]
//         dE = 2 * field[n, m] * total
//         if dE <= 0:
//             field[n, m] *= -1
//         elif np.exp(-dE * beta) > np.random.rand():
//             field[n, m] *= -1

        for (int i = 0; i < Schritte; i++) {
            s1 = {0, 0};

            // matrixmultiplikation
            for (int i = 0; i < s0.size(); i++) {
                for (int j = 0; j < s0.size(); j++){
                    s1[i] += (s0[j] * M[j][i]);
                }
            }

            // Energiedifferenz zwischen Zustand i, i+1
            // Hamiltonian(E) = Magnetfeldstaerke(H) * Spin(S)
            double dE = H * (s1[0] - s0[0] + s1[1] - s0[1]);

            // Spin Flip
            if (0.5 < dist_uni(rng)) {
                double help = s1[0];
                s1[0] = s1[1];
                s1[1] = help;
            }

            s0 = s1;

        }

        // ausgabe
        if (myfile.is_open()) {
            std::cout << "H = " << H << " :  [ ";
            myfile << H << ",";
            for (int i = 0; i < s1.size(); i++) {
                std::cout << s1[i] << " " ;  // terminal
                myfile << s1[i] << ","; // file
            }
            std::cout << "]" << std::endl;
            myfile << std::endl;
        }
    }
    myfile.close();
    return 0;
}
